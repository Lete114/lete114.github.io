{
    "version": "https://jsonfeed.org/version/1",
    "title": "Lete乐特 's Blog • All posts by \"css\" tag",
    "description": "我相信我可以，但我一直在路上，所以我有无限的可能！！",
    "home_page_url": "https://blog.imlete.cn",
    "items": [
        {
            "id": "https://blog.imlete.cn/article/Static-resource-cache-control.html",
            "url": "https://blog.imlete.cn/article/Static-resource-cache-control.html",
            "title": "前端优化之静态资源缓存控制",
            "date_published": "2022-05-12T11:51:45.000Z",
            "content_html": "<blockquote>\n<p>本文转自<a href=\"https://www.zhihu.com/question/20790576/answer/32602154\">@张云龙</a>，于 2014 年 10 月在知乎上的一个问题回答，博主觉得这位大佬写的很好，也很详细，于是就把内容搬到了自己的博客上，便于以后自己查阅</p>\n</blockquote>\n<h2 id=\"太长不想看\"><a href=\"#太长不想看\" class=\"headerlink\" title=\"太长不想看\"></a>太长不想看</h2><p>使用强制缓存如何，如何让用户能够及时使用最新修改后的静态资源？</p>\n<ol>\n<li>修改资源文件名<code>index-v1.css</code></li>\n<li>修改资源文件名，并且对文件内容生成 hash 值(内容改变，则 hash 改变反之不改变)(<code>index.v1tg6l.css</code>)</li>\n<li>为资源添加请求参数(该参数没有任何作用，只是为了修改 url 地址)与第二条一样生成 hash(<code>index.css?v=qb6l0p</code>)</li>\n</ol>\n<blockquote>\n<p>总结: 只要修改了资源请求的 url 地址，那么就会获取最新修改的静态资源，从而主动弃用旧静态资源<br>很多大网站都会使用这种方式，例如 baidu，taobao</p>\n</blockquote>\n<h2 id=\"什么是-HTTP-缓存\"><a href=\"#什么是-HTTP-缓存\" class=\"headerlink\" title=\"什么是 HTTP 缓存\"></a>什么是 HTTP 缓存</h2><p>HTTP 缓存分为两种(本文不会深究响应头的众多参数)</p>\n<ul>\n<li>强制缓存: (状态码始终 200)在规定时间内，不用向服务器发送请求，直接使用本地缓存(超过规定时间后才会重新向服务器发送请求获取资源)</li>\n<li>协商缓存: (状态码过期 200，未过期 304)每次都会向服务器确认，这个本地资源有没有过期，过期: 服务器返回新资源。未过期: 让浏览器使用本地缓存</li>\n</ul>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>使用强制缓存如何，如何让用户能够及时使用最新修改后的静态资源？</p>\n<p>这是一个普通网站的结构<br><img src=\"/img/Static-resource-cache-control/1.png\" alt=\"\"></p>\n<p>访问这个网站，可以看到网络请求状态，响应状态 200，这是在正常不过的事了<br>那就看看<code>a.css</code>的请求吧，如果每次用户访问页面都要加载，是不是很影响性能，很浪费带宽啊<br><img src=\"/img/Static-resource-cache-control/2.png\" alt=\"\"></p>\n<p>我们希望最好这样,利用 304，让浏览器使用本地缓存。但，这样就够了吗？不成！<strong>304 叫协商缓存</strong>，这玩意儿还是需要向浏览器发送一个请求，问问服务器这个资源有没有更新</p>\n<blockquote>\n<p>更新: 返回新资源<br>没更新: 告诉浏览器使用本地缓存</p>\n</blockquote>\n<p><img src=\"/img/Static-resource-cache-control/3.png\" alt=\"\"></p>\n<p>使用<strong>强制缓存（cache-control/expires）</strong>让浏览器不要向服务器发送请求了<br>所以必须彻底灭掉这个请求，变成这样<br><img src=\"/img/Static-resource-cache-control/4.png\" alt=\"\"></p>\n<p>那问题来了：这都不让浏览器发资源请求了，这缓存咋更新？<br>可以通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源<br><img src=\"/img/Static-resource-cache-control/5.png\" alt=\"\"></p>\n<p>下次上线资源的时候，把链接地址改成新的版本，这就能更新资源了<br><img src=\"/img/Static-resource-cache-control/6.png\" alt=\"\"></p>\n<p>页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本(当然你如果只改 a 的链接地址就可以了，不过我们还是要继续讨论后续问题)，就会导致 b.css，c.css 的缓存也失效，那岂不是又有浪费了？！<br>要解决这种问题，必须让 url 的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应 url 的变更，从而实现文件级别的精确缓存控制。</p>\n<p>可以使用<strong>数据摘要算法</strong>，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了</p>\n<p>这回再有文件修改，就只更新那个文件对应的 url 了，想到这里貌似很完美了<br><img src=\"/img/Static-resource-cache-control/7.png\" alt=\"\"></p>\n<p>现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到 CDN 节点上，网页中引用的资源也会变成对应的部署路径<br><img src=\"/img/Static-resource-cache-control/8.png\" alt=\"\"></p>\n<p>好了，当我要更新静态资源的时候，同时也会更新 html 中的引用吧，就好像这样<br><img src=\"/img/Static-resource-cache-control/9.png\" alt=\"\"></p>\n<p>但是这会产生一个问题，如何保证页面与资源保持一致呢？</p>\n<ul>\n<li>先部署页面，再部署资源<ul>\n<li>在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。</li>\n</ul>\n</li>\n<li>先部署资源，再部署页面<ul>\n<li>在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>简而言之: 先部署谁都不成！都会导致部署过程中发生页面错乱的问题。<br>所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。</p>\n</blockquote>\n<p>但是如果你现在正在维护一个用户访问量比较大的网站，改怎么办，你打算不解决了吗？</p>\n<p>可以采用<strong>非覆盖式发布</strong>，前面我们说了那么多都是<strong>覆盖式发布</strong><br><img src=\"/img/Static-resource-cache-control/10.png\" alt=\"\"></p>\n<p>全套做下来，就是相对比较完整的静态资源缓存控制方案了，而且，还要注意的是，静态资源的缓存控制要求在前端所有静态资源加载的位置都要做这样的处理。是的，所有！什么 js、css 自不必说，还要包括 js、css 文件中引用的资源路径，由于涉及到摘要信息，引用资源的摘要信息也会引起引用文件本身的内容改变，从而形成级联的摘要变化，大概就是如下图<br><img src=\"/img/Static-resource-cache-control/11.png\" alt=\"\"></p>\n",
            "tags": [
                "CSS",
                "JavaScript",
                "HTML",
                "Cache"
            ]
        },
        {
            "id": "https://blog.imlete.cn/article/CSS-units.html",
            "url": "https://blog.imlete.cn/article/CSS-units.html",
            "title": "CSS单位你真的了解吗？",
            "date_published": "2021-07-17T11:30:17.000Z",
            "content_html": "<p>CSS 常见单位：px、%、em、rem、vh、vw<br>全部单位：%、px、cm、mm、in、pt、pc、ch、em、 ex、rem、vh、vw、vmin、vmax</p>\n<p>本文主要内容只会讲解常见 css 单位，并不会过深的去探讨(学而用不到，很快就会忘记)</p>\n<table>\n<thead>\n<tr>\n<th>单位</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>px</td>\n<td>像素(Pixel)是相对长度单位，px 是相对于显示器屏幕分辨率而言的单位</td>\n</tr>\n<tr>\n<td>%</td>\n<td>百分比</td>\n</tr>\n<tr>\n<td>em</td>\n<td>em 的值并不是固定的，他会继承父级元素的大小</td>\n</tr>\n<tr>\n<td>rem</td>\n<td>rem 是 CSS3 新增的一个相对单位（root em，根 em）,表示 rem 会相对于 html 根元素，而 em 是相对于父元素</td>\n</tr>\n<tr>\n<td>vh</td>\n<td>视图窗口的高度(viewport heigth)</td>\n</tr>\n<tr>\n<td>vw</td>\n<td>视图窗口的宽度(viewport width)</td>\n</tr>\n</tbody></table>\n<p><code>1px</code>：是相对单位，不管窗体怎么变化，它都是定死的</p>\n<p><code>1%</code>：是相对单位，它是相对于父元素的百分比，举例：父元素宽度为 100px，子元素设置 50%，那么子元素是父元素的一半(50px)</p>\n<p><code>em</code>：是相对单位，它是相对于父元素的，举例：父元素字体大小为 20px，子元素设置 2em，那么子元素 40px。如果直接在 body 里使用，而为修改过 body 的默认大小，那么 html 的默认大小是 14px，如果写 2em 的话就是 28px</p>\n<p><code>rem</code>：是相对单位，它是相对于根(root em)的缩写，相对于根元素的大小，与 em 不同的是 em 是相对与父元素指定的大小，而 rem 是相对于根元素大小</p>\n<p><code>vh</code>：是相对单位，它是相对与窗体高度(也就是浏览器显示区域的高度)，举例：如果你现在使用手机浏览，假设手机高 200px,宽 100px，那么 1vh=20px，1vw=10px</p>\n<p><code>vw</code>：是相对单位，它是相对与窗体宽度(也就是浏览器显示区域的宽度)，举例：同上 vh</p>\n",
            "tags": [
                "CSS",
                "记录"
            ]
        },
        {
            "id": "https://blog.imlete.cn/article/Css-Anchor-scroll.html",
            "url": "https://blog.imlete.cn/article/Css-Anchor-scroll.html",
            "title": "使用Css实现与JavaScript相同的丝滑锚点滚动效果",
            "date_published": "2021-05-04T10:42:07.000Z",
            "content_html": "<p>曾经我认为网站的锚点滚动效果都是使用Javscript实现的，如果不用js实现的话就是一瞬间就跳转到了，用户体验较差<br>看了大部分网站都是用js实现的，直到我写了Hexo的<a href=\"https://mengd.js.org\">Hexo-MengD(萌典)</a>主题后<br>了解到了很多前端更深层的一些知识，我才知道原来这种效果可以使用css实现，甚至只需要一行即可实现，而如果使用的是js实现的话，少则<code>50行</code>代码、多则<code>100+行</code>代码<br>现在就只需要一行css就能实现，而且css的效率是完全吊打js的</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">    scroll-behavior: smooth;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就给html标签添加一个css属性样式就可以了，没了(是不是很震惊？)</p>\n",
            "tags": [
                "CSS",
                "JavaScript"
            ]
        },
        {
            "id": "https://blog.imlete.cn/article/a5ef8356.html",
            "url": "https://blog.imlete.cn/article/a5ef8356.html",
            "title": "CSS修改滚动条颜色样式(右边滚动条、底部滚动条、div内滚动条)",
            "date_published": "2020-05-18T14:10:52.000Z",
            "content_html": "<h2 id=\"如下\"><a href=\"#如下\" class=\"headerlink\" title=\"如下\"></a>如下</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 滚动条宽度 */</span></span><br><span class=\"line\">::-webkit-scrollbar&#123;<span class=\"attribute\">width</span>:<span class=\"number\">1px</span>;&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 滚动条轨道颜色 */</span></span><br><span class=\"line\">::-webkit-scrollbar-track&#123;<span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 滚动条颜色 */</span></span><br><span class=\"line\">::-webkit-scrollbar-thumb&#123;<span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 鼠标移动到滚动条上后显示的颜色 */</span></span><br><span class=\"line\">::-webkit-scrollbar-thumb:hover &#123;<span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 点击时滚动条的颜色 */</span></span><br><span class=\"line\">::-webkit-scrollbar-thumb:active &#123;<span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"【Lete乐特个人博客】：https-lete114-now-sh\"><a href=\"#【Lete乐特个人博客】：https-lete114-now-sh\" class=\"headerlink\" title=\"【Lete乐特个人博客】：https://lete114.now.sh\"></a>【Lete乐特个人博客】：<a href=\"https://lete114.now.sh\">https://lete114.now.sh</a></h3>",
            "tags": [
                "CSS"
            ]
        }
    ]
}